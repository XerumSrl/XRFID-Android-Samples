@page "/PrintLabels"
@using AutoMapper;
@using System.Text.Json;
@using System.ComponentModel.DataAnnotations;
@using XRFID.Sample.Server.Repositories;
@using XRFID.Sample.Server.ViewModels;

@inject PrinterRepository printerRepository;
@inject LabelRepository labelRepository;
@inject IMapper mapper

<h3>PrintPage</h3>

<MudForm @ref="form" @bind-IsValid="@success" @bind-Errors="@errors">
    <MudSelect T="PrinterModel" Label="Printer" Variant="Variant.Outlined" AnchorOrigin="Origin.BottomCenter" Required="true" @bind-Value="selectedPrinter">
        @foreach (var printer in printers)
        {
            <MudSelectItem Value="@printer">@printer.Name</MudSelectItem>
        }
    </MudSelect>
    <MudSelect T="LabelModel" Label="Label" Variant="Variant.Outlined" AnchorOrigin="Origin.BottomCenter" Required="true" Value="@selectedLabel" ValueChanged="GetVariables">
        @foreach (var label in labels)
        {
            <MudSelectItem Value="@label">@label.Name Rev. @label.Version</MudSelectItem>
        }
    </MudSelect>
    @if (selectedLabel is not null)
    {
        @foreach (var variable in variables)
        {
            if (variable.Name.Equals("epc", StringComparison.InvariantCultureIgnoreCase))
            {
                <MudTextField T="string" Label="@variable.Name" @bind-Value="@variable.Value" Required="true" RequiredError="@(variable.Name+ " is required")" Validation="@( new RegularExpressionAttribute(@"^([0-9a-fA-F]{32}|[0-9a-fA-F]{24})$"))" ErrorText="EPC must be a valix HEX rapresentation of 24 or 32 charachers" />
            }
            else
            {
                <MudTextField T="string" Label="@variable.Name" @bind-Value="@variable.Value" />
            }
            
        }
    }
</MudForm>

@code {
    bool success;
    string[] errors = { };
    MudForm form;

    private List<PrinterModel> printers = new List<PrinterModel>();
    private List<LabelModel> labels = new List<LabelModel>();

    private PrinterModel? selectedPrinter;
    private LabelModel? selectedLabel;

    private List<ZPLVar> variables = new List<ZPLVar>();

    protected override async Task OnInitializedAsync()
    {
        printers = mapper.Map<List<PrinterModel>>(await printerRepository.GetAsync());
        labels = mapper.Map<List<LabelModel>>(await labelRepository.GetAsync());
    }

    private void GetVariables(LabelModel label)
    {
        selectedLabel = label;
        variables.Clear();
        if (selectedLabel is null)
        {
            return;
        }

        int startIndex = 0;
        do
        {
            int openIndex = selectedLabel.Content.IndexOf("{", startIndex + 1);
            if (openIndex == -1)
            {
                break;
            }

            int closeIndex = selectedLabel.Content.IndexOf("}", openIndex + 1);

            if (closeIndex == -1 || openIndex + 1 == closeIndex)
            {
                throw new Exception("no closing bracket found or variablename is 0 characters long");
            }

            string variableName = selectedLabel.Content.Substring(openIndex + 1, closeIndex - openIndex - 1);

            variables.Add(new ZPLVar { Name = variableName, OpenBraketIndex = openIndex, CloseBraketIndex = closeIndex });

            startIndex = closeIndex + 1;

        } while (true);
    }

    private class ZPLVar
    {
        public string Name { get; set; } = string.Empty;
        public string? Value { get; set; }
        public int OpenBraketIndex { get; set; }
        public int CloseBraketIndex { get; set; }

        public override string ToString()
        {
            return JsonSerializer.Serialize(this, this.GetType(), new JsonSerializerOptions { WriteIndented = true });
        }

        public override bool Equals(object? obj)
        {
            if (obj is null)
            {
                return false;
            }
            if (obj.GetType() != this.GetType())
            {
                return false;
            }
            var o = (ZPLVar)obj;
            return Name == o.Name && Value == o.Value && OpenBraketIndex == o.OpenBraketIndex && CloseBraketIndex == o.CloseBraketIndex;
        }

        public override int GetHashCode()
        {
            return HashCode.Combine(Name, Value, OpenBraketIndex, CloseBraketIndex);
        }
    }
}
